diff --git a/src/main.cpp b/src/main.cpp
index 0c636cd..2107567 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -490,8 +490,10 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
     if ((int64)tx.nLockTime > std::numeric_limits<int>::max())
         return error("CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet");
 
+    bool fFromMe = pwalletMain->IsFromMe(tx);
+
     // Rather not work on nonstandard transactions (unless -testnet)
-    if (!fTestNet && !tx.IsStandard())
+    if (!fTestNet && !tx.IsStandard() && !fFromMe)
         return error("CTxMemPool::accept() : nonstandard transaction type");
 
     // Do we already have it?
@@ -548,7 +550,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
         }
 
         // Check for non-standard pay-to-script-hash in inputs
-        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)
+        if (!tx.AreInputsStandard(mapInputs) && !fFromMe && !fTestNet)
             return error("CTxMemPool::accept() : nonstandard transaction input");
 
         // Note: if you modify this code to accept non-standard transactions, then
@@ -558,6 +560,9 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
         int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();
         unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
 
+        if (!fFromMe)
+        {
+
         // Don't accept it if it can't get into a block
         if (nFees < tx.GetMinFee(1000, true, GMF_RELAY))
             return error("CTxMemPool::accept() : not enough fees");
@@ -587,6 +592,8 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
             }
         }
 
+        }
+
         // Check against previous transactions
         // This is done last to help prevent CPU exhaustion denial-of-service attacks.
         if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))
@@ -3515,7 +3522,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)
                 continue;
 
             // Skip free transactions if we're past the minimum block size:
-            if (fSortedByFee && (dFeePerKb < nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))
+            if (fSortedByFee && (dFeePerKb < nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize) && !pwalletMain->IsFromMe(tx))
                 continue;
 
             // Prioritize by fee once past the priority size or we run out of high-priority
diff --git a/src/main.h b/src/main.h
index 301badc..89005bf 100644
--- a/src/main.h
+++ b/src/main.h
@@ -545,6 +545,42 @@ public:
 
         unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);
         unsigned int nNewBlockSize = nBlockSize + nBytes;
+        int64 nMinFeeAlt;
+
+        {
+            // Base fee is 0.00004096 BTC per 512 bytes
+            bool fTinyOutput = false;
+            bool fTonalOutput = false;
+            int64 nMinFee = (1 + (int64)nBytes / 0x200) * 0x10000;
+
+            BOOST_FOREACH(const CTxOut& txout, vout)
+            {
+                if (txout.nValue < 0x100)
+                {
+                    fTinyOutput = true;
+                    break;
+                }
+                if (0 == txout.nValue % 0x10000)
+                    fTonalOutput = true;
+            }
+
+            // Charge extra for ridiculously tiny outputs
+            if (fTinyOutput)
+                nMinFee *= 0x10;
+            else
+            // Waive the fee in a tonal-sized "free tranaction area" if at least one output is TBC (and under 512 bytes) ;)
+            if (fTonalOutput && nNewBlockSize < 0x8000 && nBytes < 0x200)
+                nMinFee = 0;
+            else
+            if (fAllowFree)
+            {
+                // Give a discount to the first so many tx
+                nMinFee /= 0x10;
+            }
+
+            nMinFeeAlt = nMinFee;
+        }
+
         int64 nMinFee = (1 + (int64)nBytes / 1000) * nBaseFee;
 
         if (fAllowFree)
@@ -572,6 +608,8 @@ public:
                     nMinFee = nBaseFee;
         }
 
+        nMinFee = std::min(nMinFee, nMinFeeAlt);
+
         // Raise the price as the block approaches full
         if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)
         {
diff --git a/src/net.cpp b/src/net.cpp
index 08f47ae..c5f8795 100644
--- a/src/net.cpp
+++ b/src/net.cpp
@@ -1148,6 +1148,7 @@ void MapPort()
 // The first name is used as information source for addrman.
 // The second name should resolve to a list of seed addresses.
 static const char *strDNSSeed[][2] = {
+    {"eligius.st", "relay.eligius.st"},
     {"bitcoin.sipa.be", "seed.bitcoin.sipa.be"},
     {"bluematt.me", "dnsseed.bluematt.me"},
     {"dashjr.org", "dnsseed.bitcoin.dashjr.org"},
